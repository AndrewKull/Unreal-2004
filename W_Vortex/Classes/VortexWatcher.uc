/*******************************************************************************
 * VortexWatcher generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2013 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class VortexWatcher extends ReplicationInfo
    hidecategories(Movement,Collision,Lighting,LightColor,Karma,Force);

var int VortexLimit;
var bool bLimitReached;
var bool bPrevLimitReached;
var int nVorticesActive;
var float VortexEndTime;

replication
{

    reliable if(Role == ROLE_Authority)
        bLimitReached;
}

function PostBeginPlay()
{
    VortexLimit = 0;
    //return;
}

function AddVortex(PlayerReplicationInfo VortexOwnerPRI)
{
    ++ nVorticesActive;
    // End:0x5D
    if(!bLimitReached)
    {
        bLimitReached = ((VortexLimit != 0) && VortexLimit > 0) && nVorticesActive >= VortexLimit;
        // End:0x5D
        if(bLimitReached)
        {
            BroadcastLocalizedMessage(class'VortexLimitMessage', VortexLimit, VortexOwnerPRI);
        }
    }
    // End:0x8B
    if(bLimitReached)
    {
        VortexEndTime = Level.TimeSeconds + class'VortexProj'.static.GetVortexDuration();
    }
    //return;
}

function RemoveVortex()
{
    -- nVorticesActive;
    bLimitReached = (VortexLimit > 0) && nVorticesActive >= VortexLimit;
    //return;
}

simulated function bool VortexLimitReached()
{
    return bLimitReached;
    //return;
}

simulated function PostNetReceive()
{
    // End:0x3B
    if(bLimitReached && !bPrevLimitReached)
    {
        VortexEndTime = Level.TimeSeconds + class'VortexProj'.static.GetVortexDuration();
    }
    bPrevLimitReached = bLimitReached;
    //return;
}

defaultproperties
{
    bNetNotify=true
}

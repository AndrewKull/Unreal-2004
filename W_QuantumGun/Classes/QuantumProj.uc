/*******************************************************************************
 * QuantumProj generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2013 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class QuantumProj extends Projectile
    dependson(QuantumShell)
    dependson(Quantumsphere);

var(Quantum) float QuantumGravity;
var(Quantum) float QuantumRange;
var(Quantum) float GravBeltScale;
var(Quantum) float InitialDelay;
var(Quantum) float BuildUpTime;
var(Quantum) float EffectsSpawnTime;
var(Quantum) float ActiveTime;
var(Quantum) float CalmDownTime;
var(Quantum) float InitialRisingRate;
var(Quantum) float MinSpeed;
var(Quantum) float MaxRisingSpeed;
var(Quantum) float SlowDownRate;
var(Quantum) float WaterSlowDownRate;
var(Quantum) float DampenFactor;
var(Quantum) float DampenFactorParallel;
var(Quantum) float KickUpSpeed;
var(Quantum) float KillRadius;
var(QuantumSounds) Sound QuantumStartSound;
var(QuantumSounds) array<Sound> QuantumFlash;
var(QuantumSounds) Sound QuantumAmbientSound;
var(QuantumSounds) array<Sound> SlurpSound;
var(QuantumSounds) array<Sound> ImpactSounds;
var(Display) Material ActiveMaterial;
var(Display) Mesh ActiveMesh;
var float StartTimeIndex;
var float StrengthFadeTimeIndex;
var float DamageTime;
var Emitter QuantumEmitter;
var Emitter QuantumMainLightning;
var Emitter QuantumLightning;
var array<QuantumSphere> QuantumSpheres;
var float EndTime;

replication
{
    reliable if((Role == ROLE_Authority) && bNetInitial)
        EndTime, InitialDelay;
}

simulated function PostBeginPlay()
{
    StartTimeIndex = Level.TimeSeconds;
    Velocity = Speed * vector(Rotation);
    RandSpin(100000.0);

    if(Instigator != none)
    {
        InstigatorController = Instigator.Controller;
    }

}

simulated event FellOutOfWorld(eKillZType KillType)
{
    return;
}

simulated function Landed(Vector HitNormal)
{
    HitWall(HitNormal, none);
}

simulated function HitWall(Vector HitNormal, Actor Wall)
{
    Velocity -= (((Velocity Dot HitNormal) * HitNormal) * (float(1) + DampenFactorParallel));
    Velocity *= DampenFactor;
}

simulated function SpawnVisualEffects()
{
    local float TimeRemaining;

    PlaySound(QuantumAmbientSound, SLOT_Interact, 255.0,, 6000.0);

    if(Level.NetMode == NM_DedicatedServer)
    {
        return;
    }
    TimeRemaining = (BuildUpTime - EffectsSpawnTime) + ActiveTime;
    QuantumSpheres[0] = Spawn(class'QuantumSphere', self);
    QuantumSpheres[0].LifeSpan = TimeRemaining;
    QuantumSpheres[1] = Spawn(class'QuantumSphereB', self);
    QuantumSpheres[1].LifeSpan = TimeRemaining;
    QuantumLightning = Spawn(class'QuantumMainLightning', self);
}

simulated function ReleaseQuantum()
{
    local Vector RandDir;
    local QuantumShell ShellPart;

    RandDir = VRand();
    ShellPart = Spawn(class'QuantumShell',,, Location + (float(2) * RandDir), rotator(RandDir));

    if(ShellPart != none)
    {
        ShellPart.Velocity = float(200) * RandDir;
    }
    ShellPart = Spawn(class'QuantumShell',,, Location - (float(2) * RandDir), rotator(-RandDir));

    if(ShellPart != none)
    {
        ShellPart.Velocity = float(-200) * RandDir;
    }

    if(Role == ROLE_Authority)
    {
        bUpdateSimulatedPosition = false;
    }

    LinkMesh(ActiveMesh);
    SetDrawScale(1.20);
    Skins[0] = ActiveMaterial;
    RepSkin = ActiveMaterial;
    /* TODO - WTF?
    UnresolvedNativeFunction_97('Flying', 1.0);
    */
    bUnlit = true;
}

simulated function SuckInActors(float Gravity, float Range, float DeltaTime)
{
    local Actor thisActor;
    local Pawn thisPawn;
    local Vector Dir, ActorLocation;
    local float dist, Strength, ActorSize;

    DamageTime += DeltaTime;

    if((Instigator == none) && InstigatorController != none)
    {
        Instigator = InstigatorController.Pawn;
    }

    foreach CollidingActors(class'Actor', thisActor, Range, Location)
    {
        if(((thisActor.isA('QuantumProj') || !IsMovable(thisActor)) || !IsVisible(thisActor)) || !FastTrace(thisActor.Location, Location))
        {
            continue;
        }
        thisPawn = Pawn(thisActor);

        if(thisActor.Physics == PHYS_Karma )
        {
            thisActor.KGetCOMPosition(ActorLocation);
            ActorSize = thisActor.GetRenderBoundingSphere().W * thisActor.DrawScale;
        } else {
            ActorLocation = thisActor.Location;
            ActorSize = 0.0;
        }

        Dir = Normal(Location - ActorLocation);
        dist = VSize(Location - ActorLocation);
        Strength = (Gravity * DeltaTime) * (2.10 - (float(2) * Square(dist / Range)));

        if((thisActor.Physics == PHYS_Karma) || thisActor.Physics == PHYS_KarmaRagDoll )
        {
            if(thisPawn.IsA('SVehicle'))
            {
                Strength = Strength / SVehicle(thisActor).VehicleMass;
            }

            if(!thisActor.KIsAwake())
            {
                thisActor.KWake();
            }
            thisActor.KAddImpulse(((Dir * Strength) * thisActor.Mass) * thisActor.KGetMass(), ActorLocation, 'bip01 Spine');
        } else {

            if(thisPawn != none)
            {
                if((thisPawn.Physics == PHYS_Walking ) && Dir.Z < float(0))
                {
                    Dir.Z = KickUpSpeed / Strength;
                }
                thisPawn.AddVelocity(Dir * Strength);
                thisPawn.DelayedDamageInstigatorController = InstigatorController;
            } else {

                if((thisActor.Physics == PHYS_None) || thisActor.Physics == PHYS_Rotating)
                {
                    if(thisActor.IsA('GameObject') && thisActor.IsInState('home'))
                    {
                        thisActor.GotoState('dropped');
                    }
                    thisActor.SetPhysics(PHYS_Falling);
                    thisActor.Velocity = vect(0.0, 0.0, 1.0) * KickUpSpeed;
                }

                if((thisActor.Physics == PHYS_Projectile) || thisActor.IsA('RipperBlade'))
                {
                    thisActor.SetRotation(thisActor.Rotation - rotator(thisActor.Velocity));
                }
                thisActor.Velocity += (Dir * Strength);

                if(thisActor.Physics == PHYS_Projectile)
                {
                    thisActor.SetRotation(thisActor.Rotation + rotator(thisActor.Velocity));
                }
            }
        }

        if(((dist < KillRadius) && IsInState('Sucking')) && !thisActor.IsA('QuantumShell'))
        {
            KillObject(thisActor, dist);
            continue;
        }

        if((dist < DamageRadius) && DamageTime > 0.20)
        {
            DamageObject(thisActor, dist);
        }
    }

    if(DamageTime > 0.20)
    {
        DamageTime -= 0.20;
    }
    if(QuantumSpheres.Length>1){
        if(QuantumSpheres[0] != none) QuantumSpheres[0].SetLocation(Location);
        if(QuantumSpheres[1] != none) QuantumSpheres[1].SetLocation(Location);
    }
}

simulated function SlowDown(float DeltaTime)
{
    if(VSize(Velocity) > MaxSpeed)
    {
        DeltaTime *= float(2);
    }

    if(!PhysicsVolume.bWaterVolume)
    {
        Speed = FMax(VSize(Velocity) - (SlowDownRate * DeltaTime), 0.0);
    }else{
        Speed = FMax(VSize(Velocity) - (WaterSlowDownRate * DeltaTime), 0.0);
    }

    if(Speed > float(0))
    {
        Velocity = Normal(Velocity) * Speed;
    } else {
        Velocity = vect(0.0, 0.0, 0.0);
        Speed = 0.0;
        SetPhysics(PHYS_Rotating);
        SetCollision(false, false, false);
    }

}

simulated function KillObject(Actor Other, float DistToCenter)
{

    if(((((Pawn(Other) != none) && Other.Role == ROLE_Authority) && Pawn(Other).Health > 0) && !Pawn(Other).InGodMode()) && !HasRespawnProtection(Pawn(Other)))
    {
        Other.TakeDamage(1000, Instigator, Other.Location, vect(0.0, 0.0, 0.0), MyDamageType);

        if(Pawn(Other) != none)
        {
            if(Pawn(Other).Health > 0)
            {
                Pawn(Other).Died(InstigatorController, MyDamageType, Other.Location);
            }
        }

        PlaySound(SlurpSound[Rand(SlurpSound.Length)], SLOT_Misc, 255.0,, 6000.0);

    } else {
        if(Pickup(Other) != none)
        {
            Other.Destroy();
        } else {
            Other.Touch(self);
            DamageObject(Other, DistToCenter);
        }
    }
}

simulated function DamageObject(Actor Other, float DistToCenter)
{
    if((Other == none) || Other.IsA('Pawn') && Other.Role < ROLE_Authority)
    {
        return;
    }

    if(!Other.IsA('Pawn') || ((Pawn(Other).Health > 0) && !Pawn(Other).InGodMode()) && !HasRespawnProtection(Pawn(Other)))
    {
        Other.TakeDamage(int(Damage * (float(1) - (DistToCenter / DamageRadius))), Instigator, Other.Location, vect(0.0, 0.0, 0.0), MyDamageType);
    }
}

simulated function bool IsVisible(Actor Other)
{
    return !Other.bHidden && (((((Other.DrawType == 2) || Other.DrawType == 8) || Other.DrawType == 1) || Other.DrawType == 7) || Other.DrawType == 4) || Other.DrawType == 5;
}

simulated function bool IsMovable(Actor Other)
{
    if(Other.bStatic || Other.bNoDelete)
    {
        return false;
    }

    if(Other.IsA('GameObject') && (Other.Physics == PHYS_None) || Other.Physics == PHYS_Rotating)
    {
        return Other.IsInState('dropped') || Other.IsInState('home');
    }

    if(Other.IsA('UnrealPawn') && ((((((Other.Physics == PHYS_Walking) || Other.Physics == PHYS_Falling) || Other.Physics == PHYS_Swimming) || Other.Physics == PHYS_Flying) || Other.Physics == PHYS_Spider) || Other.Physics == PHYS_Ladder) || Other.Physics == PHYS_KarmaRagDoll)
    {
        return true;
    }

    if(Other.IsA('Pickup') && Pickup(Other).bDropped)
    {
        return true;
    }

    return ((Other.Physics == PHYS_Projectile) || Other.Physics == PHYS_Falling) || Other.Physics == PHYS_Karma;
}


simulated function bool HasRespawnProtection(Pawn Other)
{
    if(DeathMatch(Level.Game) == none)
    {
        return false;
    }

    if((Level.TimeSeconds - Other.SpawnTime) < DeathMatch(Level.Game).SpawnProtectionTime)
    {
        return true;
    }
    return false;
}

static simulated function float GetQuantumDuration()
{
    return ((default.InitialDelay + default.BuildUpTime) + default.ActiveTime) + default.CalmDownTime;
}

auto simulated state Flying
{
    simulated function ProcessTouch(Actor Other, Vector HitLocation)
    {
        if(Other != Instigator)
        {
            HitWall(Normal(Other.Location - Location), Other);
        }
    }

    simulated function HitWall(Vector HitNormal, Actor Wall)
    {
        global.HitWall(HitNormal, Wall);

        if(VSize(Velocity) > float(80))
        {
            PlaySound(ImpactSounds[Rand(ImpactSounds.Length)], SLOT_Misc,,,, 1.50);
        }
    }

    simulated function BeginState()
    {
        //return;
    }

Begin:
    Sleep(InitialDelay);
    GotoState('StartSucking');
    stop;
}

simulated state StartSucking
{
    simulated function BeginState()
    {
        StrengthFadeTimeIndex = Level.TimeSeconds;


        if(Physics != PHYS_Projectile){
            SetPhysics(PHYS_Projectile);
            Acceleration = vect(0.0, 0.0, 1.0) * InitialRisingRate;
            MaxSpeed = MaxRisingSpeed;
        }

        ReleaseQuantum();
        bProjTarget = false;
        SetCollision(false, false, false);
        SetTimer(EffectsSpawnTime, false);
        /*

        ---   TODO what is this!!! ---

        LightType = 4;
        */
        LightRadius = 1.0;
    }

    simulated function Timer()
    {
        SpawnVisualEffects();
    }

    simulated function Tick(float DeltaTime)
    {
        local float StrengthScale;

        StrengthScale = (Level.TimeSeconds - StrengthFadeTimeIndex) / BuildUpTime;
        SuckInActors(QuantumGravity * StrengthScale, QuantumRange * StrengthScale, DeltaTime);
        LightRadius = (default.LightRadius * (BuildUpTime - LatentFloat)) / BuildUpTime;
    }

    simulated function EndState()
    {
        Acceleration = vect(0.0, 0.0, 0.0);
    }

Begin:
    QuantumEmitter = Spawn(class'QuantumEmitter', self);
    QuantumEmitter.LifeSpan = (BuildUpTime + ActiveTime) + CalmDownTime;
    PlaySound(QuantumStartSound, SLOT_Misc, 255.0,, 6000.0);
    Sleep(BuildUpTime);
    GotoState('Sucking');
    stop;
}

simulated state Sucking
{
    simulated function Tick(float DeltaTime)
    {
        SuckInActors(QuantumGravity, QuantumRange, DeltaTime);

        if(Physics != PHYS_Projectile)
        {
              SlowDown(DeltaTime);
        }

        if(Level.TimeSeconds >= EndTime)
        {
            GotoState('Collapsing');
        }

    }

    simulated function BeginState()
    {
        QuantumMainLightning = Spawn(class'QuantumFX', self);
        Timer();
    }

    simulated function Timer()
    {
        local Sound S;

        S = QuantumFlash[Rand(QuantumFlash.Length)];

        PlaySound(S, SLOT_Misc, 255.0,, 6000.0);

        if(LatentFloat > GetSoundDuration(S))
        {
            SetTimer(GetSoundDuration(S) + FRand(), false);
        }
    }

    simulated function EndState()
    {
        SetTimer(0.0, false);
    }

Begin:
    EndTime = Level.TimeSeconds + ActiveTime;
    Sleep(ActiveTime);
    GotoState('Collapsing');
    stop;
}

simulated state Collapsing
{
    simulated function BeginState()
    {
        if(QuantumEmitter != none)
        {
            QuantumEmitter.Kill();
        }

        if(QuantumLightning != none)
        {
            QuantumLightning.Kill();
        }

        if(QuantumMainLightning != none)
        {
            QuantumMainLightning.Kill();
        }

        StrengthFadeTimeIndex = Level.TimeSeconds;
    }

    simulated function Tick(float DeltaTime)
    {
        local float StrengthScale;

        StrengthScale = 1.0 - ((Level.TimeSeconds - StrengthFadeTimeIndex) / CalmDownTime);
        SuckInActors(QuantumGravity * StrengthScale, QuantumRange * StrengthScale, DeltaTime);

        if(Physics != PHYS_Rotating )
        {
            SlowDown(DeltaTime);
        }
        LightRadius = (default.LightRadius * LatentFloat) / CalmDownTime;

    }

Begin:
    Sleep(CalmDownTime);
    Destroy();
    stop;
}

defaultproperties
{
//    QuantumGravity=2000.0
    QuantumGravity=2500.0
    QuantumRange=2500.0
    GravBeltScale=0.30
    InitialDelay=2.0
    BuildUpTime=2.0
    EffectsSpawnTime=1.0
    ActiveTime=9.70
    CalmDownTime=0.80
//    InitialRisingRate=50.0
    InitialRisingRate=5.0

    MinSpeed=300.0
    MaxRisingSpeed=200.0
//    SlowDownRate=100.0
    SlowDownRate=0.0
    WaterSlowDownRate=150.0
    DampenFactor=0.50
    DampenFactorParallel=0.750
    KickUpSpeed=80.0
    KillRadius=150.0
    QuantumStartSound=Sound'QuantumSounds.Vortex.Vortex_start'
    QuantumFlash(0)=Sound'QuantumSounds.Vortex.Vortex_flash1'
    QuantumFlash(1)=Sound'QuantumSounds.Vortex.Vortex_flash2'
    QuantumFlash(2)=Sound'QuantumSounds.Vortex.Vortex_flash3'
    QuantumFlash(3)=Sound'QuantumSounds.Vortex.Vortex_flash4'
    QuantumFlash(4)=Sound'QuantumSounds.Vortex.Vortex_flash5'
    QuantumFlash(5)=Sound'QuantumSounds.Vortex.Vortex_flash6'
    QuantumFlash(6)=Sound'QuantumSounds.Vortex.Vortex_flash7'
    QuantumAmbientSound=Sound'QuantumSounds.Vortex.Vortex_run'
    SlurpSound(0)=Sound'QuantumSounds.Vortex.Vortex_slurp'
    SlurpSound(1)=Sound'QuantumSounds.Vortex.Vortex_slurp1'
    SlurpSound(2)=Sound'QuantumSounds.Vortex.Vortex_slurp2'
    SlurpSound(3)=Sound'QuantumSounds.Vortex.Vortex_slurp3'
    SlurpSound(4)=Sound'QuantumSounds.Vortex.Vortex_slurp4'
    ImpactSounds(0)=Sound'QuantumSounds.Vortex.Vortexshellbounce1'
    ImpactSounds(1)=Sound'QuantumSounds.Vortex.Vortexshellbounce2'
    ImpactSounds(2)=Sound'QuantumSounds.Vortex.Vortexshellbounce3'
    ActiveMaterial=TexEnvMap'AWGlobal.Cubes.BriteEnv1'
    ActiveMesh=VertMesh'XWeapons_rc.GoopMesh'
    Speed=600.0
//    MaxSpeed=1200.0
    MaxSpeed=1200.0
    Damage=10.0
    DamageRadius=400.0
    MyDamageType=class'DamTypeQuantum'
    LightEffect=21
    LightHue=140
    LightSaturation=20
    LightBrightness=150.0
    LightRadius=75.0
    bDynamicLight=true
    bNetTemporary=false
    bUpdateSimulatedPosition=true

    Physics=PHYS_Projectile
    LifeSpan=0.0
    Mesh=SkeletalMesh'Quantum-Ani2.Chaos_VXsphere'
    DrawScale=1.20
    AmbientGlow=80
    SoundVolume=255
    SoundRadius=6000.0
    TransientSoundVolume=255.0
    TransientSoundRadius=6000.0
    CollisionRadius=10.0
    CollisionHeight=10.0
    bProjTarget=true
    bBounce=true
}

/*******************************************************************************
 * VortexProj generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2013 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class VortexProj extends Projectile
    dependson(VortexShell)
    dependson(Vortexsphere)
    dependson(VortexWatcher);

var(Vortex) float VortexGravity;
var(Vortex) float VortexRange;
var(Vortex) float GravBeltScale;
var(Vortex) float InitialDelay;
var(Vortex) float BuildUpTime;
var(Vortex) float EffectsSpawnTime;
var(Vortex) float ActiveTime;
var(Vortex) float CalmDownTime;
var(Vortex) float InitialRisingRate;
var(Vortex) float MinSpeed;
var(Vortex) float MaxRisingSpeed;
var(Vortex) float SlowDownRate;
var(Vortex) float WaterSlowDownRate;
var(Vortex) float DampenFactor;
var(Vortex) float DampenFactorParallel;
var(Vortex) float KickUpSpeed;
var(Vortex) float KillRadius;
var(VortexSounds) Sound VortexStartSound;
var(VortexSounds) array<Sound> VortexFlash;
var(VortexSounds) Sound VortexAmbientSound;
var(VortexSounds) array<Sound> SlurpSound;
var(VortexSounds) array<Sound> ImpactSounds;
var(Display) Material ActiveMaterial;
var(Display) Mesh ActiveMesh;
var float StartTimeIndex;
var float StrengthFadeTimeIndex;
var float DamageTime;
var Emitter VortexEmitter;
var Emitter VortexMainLightning;
var Emitter VortexLightning;
var array<Vortexsphere> VortexSpheres;
var VortexWatcher VortexWatcher;
var float EndTime;

replication
{
    // Pos:0x000
    reliable if((Role == ROLE_Authority) && bNetInitial)
        EndTime, InitialDelay;
}

simulated function PostBeginPlay()
{
    StartTimeIndex = Level.TimeSeconds;
    Velocity = Speed * vector(Rotation);
    RandSpin(100000.0);
    // End:0x52
    if(Instigator != none)
    {
        InstigatorController = Instigator.Controller;
    }
    // End:0x10E
    if(Role == ROLE_Authority)
    {
        // End:0xC1 TODO I commented this out
 //       if(class'ChaosUT'.default.VortexLimit != 0)
//        {
            // End:0x8A
            foreach DynamicActors(class'VortexWatcher', VortexWatcher)
            {
                // End:0x8A
                break;
            }
            // End:0xA4
            if(VortexWatcher == none)
            {
                VortexWatcher = Spawn(class'VortexWatcher');
            }
            VortexWatcher.AddVortex(Instigator.PlayerReplicationInfo);
//        }


    }
    //return;
}

simulated event FellOutOfWorld(eKillZType KillType)
{
    return;
}

simulated function Destroyed()
{
    // End:0x1A
    if(VortexWatcher != none)
    {
        VortexWatcher.RemoveVortex();
    }

}

function ProcessTouch(Actor Other, Vector HitLocation)
{
    //return;
}

simulated function Landed(Vector HitNormal)
{
    HitWall(HitNormal, none);
    //return;
}

simulated function HitWall(Vector HitNormal, Actor Wall)
{
    Velocity -= (((Velocity Dot HitNormal) * HitNormal) * (float(1) + DampenFactorParallel));
    Velocity *= DampenFactor;
    //return;
}

simulated function SpawnVisualEffects()
{
    local float TimeRemaining;

    PlaySound(VortexAmbientSound, SLOT_Interact, 255.0,, 6000.0);
    // End:0x30
    if(Level.NetMode == NM_DedicatedServer)
    {
        return;
    }
    TimeRemaining = (BuildUpTime - EffectsSpawnTime) + ActiveTime;
    VortexSpheres[0] = Spawn(class'Vortexsphere', self);
    VortexSpheres[0].LifeSpan = TimeRemaining;
    VortexSpheres[1] = Spawn(class'VortexSphereB', self);
    VortexSpheres[1].LifeSpan = TimeRemaining;
    VortexLightning = Spawn(class'VortexMainLightning', self);
    //return;
}

simulated function ReleaseVortex()
{
    local Vector RandDir;
    local VortexShell ShellPart;

    RandDir = VRand();
    ShellPart = Spawn(class'VortexShell',,, Location + (float(2) * RandDir), rotator(RandDir));
    // End:0x56
    if(ShellPart != none)
    {
        ShellPart.Velocity = float(200) * RandDir;
    }
    ShellPart = Spawn(class'VortexShell',,, Location - (float(2) * RandDir), rotator(-RandDir));
    // End:0xA9
    if(ShellPart != none)
    {
        ShellPart.Velocity = float(-200) * RandDir;
    }
    // End:0xC1
    if(Role == ROLE_Authority)
    {
        bUpdateSimulatedPosition = false;
    }
    LinkMesh(ActiveMesh);
    SetDrawScale(1.20);
    Skins[0] = ActiveMaterial;
    RepSkin = ActiveMaterial;
    /* TODO - WTF?
    UnresolvedNativeFunction_97('Flying', 1.0);
    */
    bUnlit = true;
    //return;
}

simulated function SuckInActors(float Gravity, float Range, float DeltaTime)
{
    local Actor thisActor;
    local Pawn thisPawn;
    local Vector Dir, ActorLocation;
    local float dist, Strength, ActorSize;
//    local ProxyMine pMine;

    DamageTime += DeltaTime;
    // End:0x38
    if((Instigator == none) && InstigatorController != none)
    {
        Instigator = InstigatorController.Pawn;
    }
    // End:0x54E
    foreach CollidingActors(class'Actor', thisActor, Range, Location)
    {
        // End:0xAB
        if(((thisActor.isA('VortexProj') || !IsMovable(thisActor)) || !IsVisible(thisActor)) || !FastTrace(thisActor.Location, Location))
        {
            continue;
        }
        thisPawn = Pawn(thisActor);
        // End:0x115
        if(thisActor.Physics == 13)
        {
            thisActor.KGetCOMPosition(ActorLocation);
            ActorSize = thisActor.GetRenderBoundingSphere().W * thisActor.DrawScale;
        }
        // End:0x134
        else
        {
            ActorLocation = thisActor.Location;
            ActorSize = 0.0;
        }
        Dir = Normal(Location - ActorLocation);
        dist = VSize(Location - ActorLocation);
        Strength = (Gravity * DeltaTime) * (2.10 - (float(2) * Square(dist / Range)));
        // End:0x285
        if((thisActor.Physics == 13) || thisActor.Physics == 14)
        {
            // End:0x1F3
            if(thisPawn.IsA('SVehicle'))
            {
                Strength = Strength / SVehicle(thisActor).VehicleMass;
            }
            // End:0x219
            if(thisPawn.IsA('HoverBoard'))
            {
                Strength = Strength * 1.50;
            }
            // End:0x23C
            if(!thisActor.KIsAwake())
            {
                thisActor.KWake();
            }
            thisActor.KAddImpulse(((Dir * Strength) * thisActor.Mass) * thisActor.KGetMass(), ActorLocation, 'bip01 Spine');
        }
        // End:0x47D
        else
        {
            // End:0x320
            if(thisPawn != none)
            {
                // End:0x2AA
                /*
                if(HasGravbelt(thisPawn))
                {
                    Strength *= GravBeltScale;
                }
                */
                // End:0x2EE
                if((thisPawn.Physics == 1) && Dir.Z < float(0))
                {
                    Dir.Z = KickUpSpeed / Strength;
                }
                thisPawn.AddVelocity(Dir * Strength);
                thisPawn.DelayedDamageInstigatorController = InstigatorController;
            }
            // End:0x47D
            else
            {
                // End:0x3BF
                if((thisActor.Physics == PHYS_None) || thisActor.Physics == PHYS_Rotating)
                {
                    // End:0x38E
                    if(thisActor.IsA('GameObject') && thisActor.IsInState('home'))
                    {
                        thisActor.GotoState('dropped');
                    }
                    thisActor.SetPhysics(PHYS_Falling);
                    thisActor.Velocity = vect(0.0, 0.0, 1.0) * KickUpSpeed;
                }
                // End:0x41B
                if((thisActor.Physics == PHYS_Projectile) || thisActor.IsA('RipperBlade'))
                {
                    thisActor.SetRotation(thisActor.Rotation - rotator(thisActor.Velocity));
                }
                thisActor.Velocity += (Dir * Strength);
                // End:0x47D
                if(thisActor.Physics == PHYS_Projectile)
                {
                    thisActor.SetRotation(thisActor.Rotation + rotator(thisActor.Velocity));
                }
            }
        }
     /*
        // End:0x4D6
        pMine = ProxyMine(thisActor);
        if(pMine != none && ! pMine.bInVortex)
        {
            pMine.bInVortex = true;
            pMine.PlayVortex();
        }
        // End:0x51D
       */

        if(((dist < KillRadius) && IsInState('Sucking')) && !thisActor.IsA('VortexShell'))
        {
            KillObject(thisActor, dist);
            // End:0x54D
            continue;
        }
        // End:0x54D

        if((dist < DamageRadius) && DamageTime > 0.20)
        {
            DamageObject(thisActor, dist);
        }
    }
    // End:0x56A
    if(DamageTime > 0.20)
    {
        DamageTime -= 0.20;
    }
    //return;
}

simulated function SlowDown(float DeltaTime)
{
    // End:0x1C
    if(VSize(Velocity) > MaxSpeed)
    {
        DeltaTime *= float(2);
    }
    // End:0x55
    if(!PhysicsVolume.bWaterVolume)
    {
        Speed = FMax(VSize(Velocity) - (SlowDownRate * DeltaTime), 0.0);
    }
    // End:0x77
    else
    {
        Speed = FMax(VSize(Velocity) - (WaterSlowDownRate * DeltaTime), 0.0);
    }
    // End:0x9B
    if(Speed > float(0))
    {
        Velocity = Normal(Velocity) * Speed;
    }
    // End:0xC4
    else
    {
        Velocity = vect(0.0, 0.0, 0.0);
        Speed = 0.0;
        SetPhysics(PHYS_Rotating);  //??? swimming?

        SetCollision(false, false, false);
    }
    //return;
}

simulated function KillObject(Actor Other, float DistToCenter)
{
    // End:0x127
    if(((((Pawn(Other) != none) && Other.Role == ROLE_Authority) && Pawn(Other).Health > 0) && !Pawn(Other).InGodMode()) && !HasRespawnProtection(Pawn(Other)))
    {
        Other.TakeDamage(1000, Instigator, Other.Location, vect(0.0, 0.0, 0.0), MyDamageType);
        // End:0x106
        if(Pawn(Other) != none)
        {
            // End:0x106
            if(Pawn(Other).Health > 0)
            {
                Pawn(Other).Died(InstigatorController, MyDamageType, Other.Location);
            }
        }

        PlaySound(SlurpSound[Rand(SlurpSound.Length)], SLOT_Misc, 255.0,, 6000.0);

    }
    // End:0x166
    else
    {
        // End:0x146
        if(Pickup(Other) != none)
        {
            Other.Destroy();
        }
        // End:0x166
        else
        {
            Other.Touch(self);
            DamageObject(Other, DistToCenter);
        }
    }
    //return;
}

simulated function DamageObject(Actor Other, float DistToCenter)
{

    if((Other == none) || Other.IsA('Pawn') && Other.Role < ROLE_Authority)
    {
        return;
    }
    // End:0xEF
    if(!Other.IsA('Pawn') || ((Pawn(Other).Health > 0) && !Pawn(Other).InGodMode()) && !HasRespawnProtection(Pawn(Other)))
    {
        Other.TakeDamage(int(Damage * (float(1) - (DistToCenter / DamageRadius))), Instigator, Other.Location, vect(0.0, 0.0, 0.0), MyDamageType);
    }
}

simulated function bool IsVisible(Actor Other)
{
    return !Other.bHidden && (((((Other.DrawType == 2) || Other.DrawType == 8) || Other.DrawType == 1) || Other.DrawType == 7) || Other.DrawType == 4) || Other.DrawType == 5;
    //return;
}

simulated function bool IsMovable(Actor Other)
{
    // End:0x28
    if(Other.bStatic || Other.bNoDelete)
    {
        return false;
    }
    // End:0x9A

    if(Other.IsA('GameObject') && (Other.Physics == PHYS_None) || Other.Physics == PHYS_Rotating)
    {
        return Other.IsInState('dropped') || Other.IsInState('home');
    }
    // End:0x16D
    if(Other.IsA('UnrealPawn') && ((((((Other.Physics == PHYS_Walking) || Other.Physics == PHYS_Falling) || Other.Physics == PHYS_Swimming) || Other.Physics == PHYS_Flying) || Other.Physics == PHYS_Spider) || Other.Physics == PHYS_Ladder) || Other.Physics == PHYS_KarmaRagDoll)
    {
        return true;
    }
    // End:0x19C
    if(Other.IsA('Pickup') && Pickup(Other).bDropped)
    {
        return true;
    }
    return ((Other.Physics == PHYS_Projectile) || Other.Physics == PHYS_Falling) || Other.Physics == PHYS_Karma;

}


simulated function bool HasRespawnProtection(Pawn Other)
{
    // End:0x1B
    if(DeathMatch(Level.Game) == none)
    {
        return false;
    }
    // End:0x5C
    if((Level.TimeSeconds - Other.SpawnTime) < DeathMatch(Level.Game).SpawnProtectionTime)
    {
        return true;
    }
    return false;
    //return;
}

static simulated function float GetVortexDuration()
{
    return ((default.InitialDelay + default.BuildUpTime) + default.ActiveTime) + default.CalmDownTime;
    //return;
}

auto simulated state Flying
{
    simulated function ProcessTouch(Actor Other, Vector HitLocation)
    {
        // End:0x31
        if(Other != Instigator)
        {
            HitWall(Normal(Other.Location - Location), Other);
        }
        //return;
    }

    simulated function HitWall(Vector HitNormal, Actor Wall)
    {
        global.HitWall(HitNormal, Wall);
        // End:0x3B
        if(VSize(Velocity) > float(80))
        {
            PlaySound(ImpactSounds[Rand(ImpactSounds.Length)], SLOT_Misc,,,, 1.50);
        }
        //return;
    }

    simulated function BeginState()
    {
        //return;
    }

Begin:
    Sleep(InitialDelay);
    GotoState('StartSucking');
    stop;
}

simulated state StartSucking
{
    simulated function BeginState()
    {
        StrengthFadeTimeIndex = Level.TimeSeconds;

        SetPhysics(PHYS_Projectile);

        Acceleration = vect(0.0, 0.0, 1.0) * InitialRisingRate;
        MaxSpeed = MaxRisingSpeed;
        ReleaseVortex();
        bProjTarget = false;
        SetCollision(false, false, false);
        SetTimer(EffectsSpawnTime, false);
                    /*    TODO what is this!!!
        LightType = 4;
*/
        LightRadius = 1.0;
        //return;
    }

    simulated function Timer()
    {
        SpawnVisualEffects();
        //return;
    }

    simulated function Tick(float DeltaTime)
    {
        local float StrengthScale;

        StrengthScale = (Level.TimeSeconds - StrengthFadeTimeIndex) / BuildUpTime;
        SuckInActors(VortexGravity * StrengthScale, VortexRange * StrengthScale, DeltaTime);
        LightRadius = (default.LightRadius * (BuildUpTime - LatentFloat)) / BuildUpTime;
        //return;
    }

    simulated function EndState()
    {
        Acceleration = vect(0.0, 0.0, 0.0);
        //return;
    }

Begin:
    VortexEmitter = Spawn(class'VortexEmitter', self);
    VortexEmitter.LifeSpan = (BuildUpTime + ActiveTime) + CalmDownTime;
    PlaySound(VortexStartSound, SLOT_Misc, 255.0,, 6000.0);
    Sleep(BuildUpTime);
    GotoState('Sucking');
    stop;
}

simulated state Sucking
{
    simulated function Tick(float DeltaTime)
    {
        SuckInActors(VortexGravity, VortexRange, DeltaTime);
        // End:0x30
        if(Physics != PHYS_Rotating)
        {
            SlowDown(DeltaTime);
        }
        // End:0x4F
        if(Level.TimeSeconds >= EndTime)
        {
            GotoState('Collapsing');
        }
        //return;
    }

    simulated function BeginState()
    {

        VortexMainLightning = Spawn(class'VortexFX', self);

        Timer();
        //return;
    }

    simulated function Timer()
    {
        local Sound S;

        S = VortexFlash[Rand(VortexFlash.Length)];

        PlaySound(S, SLOT_Misc, 255.0,, 6000.0);

        // End:0x51
        if(LatentFloat > GetSoundDuration(S))
        {
            SetTimer(GetSoundDuration(S) + FRand(), false);
        }
        //return;
    }

    simulated function EndState()
    {
        SetTimer(0.0, false);
        //return;
    }

Begin:
    EndTime = Level.TimeSeconds + ActiveTime;
    Sleep(ActiveTime);
    GotoState('Collapsing');
    stop;
}

simulated state Collapsing
{
    simulated function BeginState()
    {
        // End:0x1A
        if(VortexEmitter != none)
        {
            VortexEmitter.Kill();
        }
        // End:0x34
        if(VortexLightning != none)
        {
            VortexLightning.Kill();
        }
        // End:0x4E
        if(VortexMainLightning != none)
        {
            VortexMainLightning.Kill();
        }
        StrengthFadeTimeIndex = Level.TimeSeconds;
        //return;
    }

    simulated function Tick(float DeltaTime)
    {
        local float StrengthScale;

        StrengthScale = 1.0 - ((Level.TimeSeconds - StrengthFadeTimeIndex) / CalmDownTime);
        SuckInActors(VortexGravity * StrengthScale, VortexRange * StrengthScale, DeltaTime);
        // End:0x67
        if(Physics != 5)
        {
            SlowDown(DeltaTime);
        }
        LightRadius = (default.LightRadius * LatentFloat) / CalmDownTime;
        //return;
    }

Begin:
    Sleep(CalmDownTime);
    Destroy();
    stop;
}

defaultproperties
{
    VortexGravity=2000.0
    VortexRange=2500.0
    GravBeltScale=0.30
    InitialDelay=2.0
    BuildUpTime=2.0
    EffectsSpawnTime=1.0
    ActiveTime=9.70
    CalmDownTime=0.80
    InitialRisingRate=50.0
    MinSpeed=300.0
    MaxRisingSpeed=200.0
    SlowDownRate=100.0
    WaterSlowDownRate=150.0
    DampenFactor=0.50
    DampenFactorParallel=0.750
    KickUpSpeed=80.0
    KillRadius=150.0
    VortexStartSound=Sound'ChaosEsounds1.Vortex.vortex_start'
    VortexFlash(0)=Sound'ChaosEsounds1.Vortex.vortex_flash1'
    VortexFlash(1)=Sound'ChaosEsounds1.Vortex.vortex_flash2'
    VortexFlash(2)=Sound'ChaosEsounds1.Vortex.vortex_flash3'
    VortexFlash(3)=Sound'ChaosEsounds1.Vortex.vortex_flash4'
    VortexFlash(4)=Sound'ChaosEsounds1.Vortex.vortex_flash5'
    VortexFlash(5)=Sound'ChaosEsounds1.Vortex.vortex_flash6'
    VortexFlash(6)=Sound'ChaosEsounds1.Vortex.vortex_flash7'
    VortexAmbientSound=Sound'ChaosEsounds1.Vortex.vortex_run'
    SlurpSound(0)=Sound'ChaosEsounds1.Vortex.vortex_slurp'
    SlurpSound(1)=Sound'ChaosEsounds1.Vortex.vortex_slurp1'
    SlurpSound(2)=Sound'ChaosEsounds1.Vortex.vortex_slurp2'
    SlurpSound(3)=Sound'ChaosEsounds1.Vortex.vortex_slurp3'
    SlurpSound(4)=Sound'ChaosEsounds1.Vortex.vortex_slurp4'
    ImpactSounds(0)=Sound'ChaosEsounds3.Vortex.vortexshellbounce1'
    ImpactSounds(1)=Sound'ChaosEsounds3.Vortex.vortexshellbounce2'
    ImpactSounds(2)=Sound'ChaosEsounds3.Vortex.vortexshellbounce3'
    ActiveMaterial=TexEnvMap'AWGlobal.Cubes.BriteEnv1'
    ActiveMesh=VertMesh'XWeapons_rc.GoopMesh'
    Speed=600.0
    MaxSpeed=1200.0
    Damage=10.0
    DamageRadius=300.0
    MyDamageType=class'DamTypeVortex'
    LightEffect=21
    LightHue=140
    LightSaturation=20
    LightBrightness=150.0
    LightRadius=75.0
    bDynamicLight=true
    bNetTemporary=false
    bUpdateSimulatedPosition=true
    Physics=2
    LifeSpan=0.0
    Mesh=SkeletalMesh'Chaos_Extras1.Chaos_VXsphere'
    DrawScale=1.20
    AmbientGlow=80
    SoundVolume=255
    SoundRadius=6000.0
    TransientSoundVolume=255.0
    TransientSoundRadius=6000.0
    CollisionRadius=10.0
    CollisionHeight=10.0
    bProjTarget=true
    bBounce=true
}

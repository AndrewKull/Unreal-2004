/*******************************************************************************
 * Vortex generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2013 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class Vortex extends Weapon
    dependson(VortexWatcher)
    dependson(VortexChargedFire)
    dependson(VortexDummyProj)
    config(User);

var VortexWatcher VortexWatcher;
var VortexDummyProj DummyProj;

simulated function ShowDummyProj()
{
    // End:0x1C
    if(DummyProj != none)
    {
        DummyProj.bHidden = false;
    }
    //return;
}

simulated function HideDummyProj()
{
    // End:0x1C
    if(DummyProj != none)
    {
        DummyProj.bHidden = true;
    }
    //return;
}

simulated function ClientWeaponThrown()
{
    HideDummyProj();
    super.ClientWeaponThrown();
    //return;
}

simulated function Destroyed()
{
    // End:0x17
    if(DummyProj != none)
    {
        DummyProj.Destroy();
    }
    super.Destroyed();
    //return;
}

function float GetAIRating()
{
    local Bot B;
    local float enemyDist;
    local Vector enemyDir;

    B = Bot(Instigator.Controller);
    // End:0x40
    if((B == none) || B.Enemy == none)
    {
        return AIRating;
    }
    enemyDir = B.Enemy.Location - Instigator.Location;
    enemyDist = VSize(enemyDir);
    // End:0xE5
    if(((enemyDist < float(1500)) || B.IsRetreating()) || (B.Squad != none) && B.Squad.CurrentOrders == 'Defend')
    {
        return AIRating + 0.40;
    }
    return AIRating;
    //return;
}

function byte BestMode()
{
    local Bot B;
    local float enemyDist;
    local Vector enemyDir;

    B = Bot(Instigator.Controller);
    // End:0x3D
    if((B == none) || B.Enemy == none)
    {
        return 0;
    }
    enemyDir = B.Enemy.Location - Instigator.Location;
    enemyDist = VSize(enemyDir);
    // End:0x8B
    if(enemyDist > float(1000))
    {
        return 1;
    }
    return 0;
    //return;
}

function float RangedAttackTime()
{
    return 6.0;
    //return;
}

function bool RecommendRangedAttack()
{
    return true;
    //return;
}

function bool RecommendLongRangedAttack()
{
    return true;
    //return;
}

function float SuggestAttackStyle()
{
    return -1.0;
    //return;
}

function float SuggestDefenseStyle()
{
    return -1.0;
    //return;
}

simulated function AnimEnd(int Channel)
{
    local name Anim;
    local float frame, Rate;

    GetAnimParams(0, Anim, frame, Rate);
    // End:0x3F
    if(FireMode[1].bIsFiring)
    {
    /*    TODO what is this?
        UnresolvedNativeFunction_97('HOLD', 1.0, 0.10);
        */
    }
    // End:0x4A
    else
    {
        super.AnimEnd(Channel);
    }
    //return;
}

simulated function PlayIdle()
{
    super.PlayIdle();
    // End:0x31
    if((Ammo[0] != none) && Ammo[0].AmmoAmount > 0)
    {
        ShowDummyProj();
    }
    //return;
}

simulated function OutOfAmmo()
{
    // End:0x31
    if((Level.NetMode == NM_Standalone) && !Instigator.IsLocallyControlled())
    {
        return;
    }
    // End:0x5D
    if(FireMode[0].bIsFiring || FireMode[1].bIsFiring)
    {
        return;
    }
    super.OutOfAmmo();
    //return;
}

simulated function float ChargeBar()
{
    // End:0x20
    if(VortexWatcher == none)
    {
        // End:0x1F
        foreach DynamicActors(class'VortexWatcher', VortexWatcher)
        {
            // End:0x1F
            break;
        }
    }
    // End:0x7E
    if((VortexWatcher != none) && VortexWatcher.VortexEndTime > Level.TimeSeconds)
    {
        return (VortexWatcher.VortexEndTime - Level.TimeSeconds) / class'VortexProj'.static.GetVortexDuration();
    }
    return FMin(1.0, FireMode[1].HoldTime / VortexChargedFire(FireMode[1]).MaxChargeTime);
    //return;
}

simulated function BringUp(optional Weapon PrevWeapon)
{
    /*    TODO what is this?

//    AmbientSound = sound'vortex_holdambient';
*/
    super.BringUp();
    //return;
}

simulated function bool PutDown()
{
    AmbientSound = none;
    return super.PutDown();
    //return;
}

simulated function bool AtVortexLimit()
{
    // End:0x20
    if(VortexWatcher == none)
    {
        // End:0x1F
        foreach DynamicActors(class'VortexWatcher', VortexWatcher)
        {
            // End:0x1F
            break;
        }
    }
    // End:0x89
    if((VortexWatcher != none) && VortexWatcher.VortexLimitReached())
    {
        // End:0x87
        if((Instigator != none) && PlayerController(Instigator.Controller) != none)
        {
            PlayerController(Instigator.Controller).ReceiveLocalizedMessage(class'VortexLimitMessage');
        }
        return true;
    }
    return false;
    //return;
}

simulated function Weapon NextWeapon(Weapon CurrentChoice, Weapon CurrentWeapon)
{
    // End:0x2C2
    if(HasAmmo())
    {
        // End:0x29
        if(CurrentChoice == none)
        {
            // End:0x26
            if(CurrentWeapon != self)
            {
                CurrentChoice = self;
            }
        }
        // End:0x2C2
        else
        {
            // End:0x131
            if((InventoryGroup == CurrentWeapon.InventoryGroup) && InventoryGroup == CurrentChoice.InventoryGroup)
            {
                // End:0x12E
                if((((GroupOffset < CurrentChoice.GroupOffset) && CurrentChoice.GroupOffset < CurrentWeapon.GroupOffset) || (CurrentWeapon.GroupOffset < GroupOffset) && GroupOffset < CurrentChoice.GroupOffset) || (CurrentChoice.GroupOffset < CurrentWeapon.GroupOffset) && CurrentWeapon.GroupOffset < GroupOffset)
                {
                    CurrentChoice = self;
                }
            }
            // End:0x2C2
            else
            {
                // End:0x2C2
                if(((((((CurrentWeapon.InventoryGroup == InventoryGroup) && CurrentWeapon.GroupOffset < GroupOffset) || (CurrentWeapon.InventoryGroup == CurrentChoice.InventoryGroup) && CurrentChoice.GroupOffset < CurrentWeapon.GroupOffset) || (CurrentChoice.InventoryGroup == InventoryGroup) && GroupOffset < CurrentChoice.GroupOffset) || (InventoryGroup < CurrentChoice.InventoryGroup) && CurrentChoice.InventoryGroup < CurrentWeapon.InventoryGroup) || (CurrentWeapon.InventoryGroup < InventoryGroup) && InventoryGroup < CurrentChoice.InventoryGroup) || (CurrentChoice.InventoryGroup < CurrentWeapon.InventoryGroup) && CurrentWeapon.InventoryGroup < InventoryGroup)
                {
                    CurrentChoice = self;
                }
            }
        }
    }
    // End:0x2D6
    if(Inventory == none)
    {
        return CurrentChoice;
    }
    // End:0x2F0
    else
    {
        return Inventory.NextWeapon(CurrentChoice, CurrentWeapon);
    }
    //return;
}

simulated function Weapon PrevWeapon(Weapon CurrentChoice, Weapon CurrentWeapon)
{
    // End:0x2C2
    if(HasAmmo())
    {
        // End:0x29
        if(CurrentChoice == none)
        {
            // End:0x26
            if(CurrentWeapon != self)
            {
                CurrentChoice = self;
            }
        }
        // End:0x2C2
        else
        {
            // End:0x131
            if((InventoryGroup == CurrentWeapon.InventoryGroup) && InventoryGroup == CurrentChoice.InventoryGroup)
            {
                // End:0x12E
                if((((GroupOffset > CurrentChoice.GroupOffset) && CurrentChoice.GroupOffset > CurrentWeapon.GroupOffset) || (CurrentWeapon.GroupOffset > GroupOffset) && GroupOffset > CurrentChoice.GroupOffset) || (CurrentChoice.GroupOffset > CurrentWeapon.GroupOffset) && CurrentWeapon.GroupOffset > GroupOffset)
                {
                    CurrentChoice = self;
                }
            }
            // End:0x2C2
            else
            {
                // End:0x2C2
                if(((((((CurrentWeapon.InventoryGroup == InventoryGroup) && CurrentWeapon.GroupOffset > GroupOffset) || (CurrentWeapon.InventoryGroup == CurrentChoice.InventoryGroup) && CurrentChoice.GroupOffset > CurrentWeapon.GroupOffset) || (CurrentChoice.InventoryGroup == InventoryGroup) && GroupOffset > CurrentChoice.GroupOffset) || (InventoryGroup > CurrentChoice.InventoryGroup) && CurrentChoice.InventoryGroup > CurrentWeapon.InventoryGroup) || (CurrentWeapon.InventoryGroup > InventoryGroup) && InventoryGroup > CurrentChoice.InventoryGroup) || (CurrentChoice.InventoryGroup > CurrentWeapon.InventoryGroup) && CurrentWeapon.InventoryGroup > InventoryGroup)
                {
                    CurrentChoice = self;
                }
            }
        }
    }
    // End:0x2D6
    if(Inventory == none)
    {
        return CurrentChoice;
    }
    // End:0x2F0
    else
    {
        return Inventory.PrevWeapon(CurrentChoice, CurrentWeapon);
    }
    //return;
}

defaultproperties
{
    FireModeClass[0]=class'VortexFire'
    FireModeClass[1]=class'VortexChargedFire'
    SelectAnim=Pickup
    PutDownAnim=PutDown
    IdleAnimRate=0.10
    SelectAnimRate=1.0
    PutDownAnimRate=1.0
    SelectSound=Sound'ChaosEsounds1.Vortex.vortex_select'
    SelectForce="SwitchToFlakCannon"
    AIRating=0.550
    CurrentRating=0.550
    bShowChargingBar=true
    bNoAmmoInstances=false
    EffectOffset=(X=100.0,Y=32.0,Z=-20.0)
    DisplayFOV=60.0
    SmallViewOffset=(X=0.0,Y=12.0,Z=-26.0)
    CenteredOffsetY=-20.0
    CustomCrosshair=3
    CustomCrossHairColor=(R=255,G=255,B=128,A=255)
    CustomCrossHairTextureName="ChaosTex_006.XHairs.vortex"
    InventoryGroup=0
    GroupOffset=64
    PickupClass=class'VortexPickup'
    PlayerViewOffset=(X=-24.0,Y=-2.0,Z=-16.0)
    PlayerViewPivot=(Pitch=0,Yaw=-16383,Roll=0)
    BobDamping=2.20
    AttachmentClass=class'VortexAttachment'
    IconMaterial=Texture'ChaosInterface.Icons.Vortex'
    IconCoords=(X1=20,Y1=48,X2=107,Y2=77)
    ItemName="Gravity Vortex"
    Mesh=SkeletalMesh'W_Vortex-Ani.chaos_vortexlauncher_1st'
    UV2Texture=Shader'XGameShaders.WeaponShaders.WeaponEnvShader'
}
